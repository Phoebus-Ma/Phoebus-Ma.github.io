
# 5. File Systems and Disk Management
--------

日志文件系统减少了恢复未正确卸载的文件系统所需的时间。虽然这在减少服务器停机时间方面非常重要，但它在桌面环境中也很流行。本章包含其他日志文件系统，您可以使用它们代替默认的LFS扩展文件系统(ext2/3/4)。它还提供了关于管理磁盘阵列的介绍性材料。


## 5.1 About initramfs
--------

initramfs的唯一目的是挂载根文件系统。initramfs是一组完整的目录，可以在正常的根文件系统中找到。它被捆绑到单个cpio归档文件中，并使用几种压缩算法中的一种进行压缩。

在引导时，引导加载程序将内核和initramfs映像加载到内存中，并启动内核。内核检查是否存在initramfs，如果找到，将其挂载为/并运行/init。init程序通常是一个shell脚本。请注意，如果使用initramfs，则引导过程需要更长的时间，可能要长得多。

对于大多数发行版，内核模块是使用initramfs的最大原因。在一般的发行版中，有许多未知的东西，比如文件系统类型和磁盘布局。在某种程度上，这与LFS相反，在LFS中，系统功能和布局是已知的，并且通常构建自定义内核。在这种情况下，很少需要initramfs。

在LFS环境中使用initramfs只有四个主要原因:从网络加载rootfs、从LVM逻辑卷加载rootfs、在需要密码的情况下使用加密的rootfs，或者为了方便将rootfs指定为LABEL或UUID。其他情况通常意味着内核配置不正确。

构建initramfs
---------------------

如果您决定构建一个initramfs，下面的脚本将提供一个基础。这些脚本允许通过分区UUID或分区LABEL指定一个rootfs，或者在LVM逻辑卷上指定一个rootfs。它们不支持加密的根文件系统，也不支持通过网卡挂载rootfs。有关更完整的功能，请参阅[the LFS Hints](https://www.linuxfromscratch.org/hints/read.html)或[dracut](https://fedoraproject.org/wiki/Dracut)。

要安装这些脚本，以`root`用户运行以下命令:

```bash
cat > /usr/sbin/mkinitramfs << "EOF"
#!/bin/bash
# This file based in part on the mkinitramfs script for the LFS LiveCD
# written by Alexander E. Patrakov and Jeremy Huntwork.

copy()
{
  local file

  if [ "$2" = "lib" ]; then
    file=$(PATH=/usr/lib type -p $1)
  else
    file=$(type -p $1)
  fi

  if [ -n "$file" ] ; then
    cp $file $WDIR/usr/$2
  else
    echo "Missing required file: $1 for directory $2"
    rm -rf $WDIR
    exit 1
  fi
}

if [ -z $1 ] ; then
  INITRAMFS_FILE=initrd.img-no-kmods
else
  KERNEL_VERSION=$1
  INITRAMFS_FILE=initrd.img-$KERNEL_VERSION
fi

if [ -n "$KERNEL_VERSION" ] && [ ! -d "/usr/lib/modules/$1" ] ; then
  echo "No modules directory named $1"
  exit 1
fi

printf "Creating $INITRAMFS_FILE... "

binfiles="sh cat cp dd killall ls mkdir mknod mount "
binfiles="$binfiles umount sed sleep ln rm uname"
binfiles="$binfiles readlink basename"

# Systemd installs udevadm in /bin. Other udev implementations have it in /sbin
if [ -x /usr/bin/udevadm ] ; then binfiles="$binfiles udevadm"; fi

sbinfiles="modprobe blkid switch_root"

# Optional files and locations
for f in mdadm mdmon udevd udevadm; do
  if [ -x /usr/sbin/$f ] ; then sbinfiles="$sbinfiles $f"; fi
done

# Add lvm if present (cannot be done with the others because it
# also needs dmsetup
if [ -x /usr/sbin/lvm ] ; then sbinfiles="$sbinfiles lvm dmsetup"; fi

unsorted=$(mktemp /tmp/unsorted.XXXXXXXXXX)

DATADIR=/usr/share/mkinitramfs
INITIN=init.in

# Create a temporary working directory
WDIR=$(mktemp -d /tmp/initrd-work.XXXXXXXXXX)

# Create base directory structure
mkdir -p $WDIR/{dev,run,sys,proc,usr/{bin,lib/{firmware,modules},sbin}}
mkdir -p $WDIR/etc/{modprobe.d,udev/rules.d}
touch $WDIR/etc/modprobe.d/modprobe.conf
ln -s usr/bin  $WDIR/bin
ln -s usr/lib  $WDIR/lib
ln -s usr/sbin $WDIR/sbin
ln -s lib      $WDIR/lib64

# Create necessary device nodes
mknod -m 640 $WDIR/dev/console c 5 1
mknod -m 664 $WDIR/dev/null    c 1 3

# Install the udev configuration files
if [ -f /etc/udev/udev.conf ]; then
  cp /etc/udev/udev.conf $WDIR/etc/udev/udev.conf
fi

for file in $(find /etc/udev/rules.d/ -type f) ; do
  cp $file $WDIR/etc/udev/rules.d
done

# Install any firmware present
cp -a /usr/lib/firmware $WDIR/usr/lib

# Copy the RAID configuration file if present
if [ -f /etc/mdadm.conf ] ; then
  cp /etc/mdadm.conf $WDIR/etc
fi

# Install the init file
install -m0755 $DATADIR/$INITIN $WDIR/init

if [  -n "$KERNEL_VERSION" ] ; then
  if [ -x /usr/bin/kmod ] ; then
    binfiles="$binfiles kmod"
  else
    binfiles="$binfiles lsmod"
    sbinfiles="$sbinfiles insmod"
  fi
fi

# Install basic binaries
for f in $binfiles ; do
  ldd /usr/bin/$f | sed "s/\t//" | cut -d " " -f1 >> $unsorted
  copy /usr/bin/$f bin
done

for f in $sbinfiles ; do
  ldd /usr/sbin/$f | sed "s/\t//" | cut -d " " -f1 >> $unsorted
  copy $f sbin
done

# Add udevd libraries if not in /usr/sbin
if [ -x /usr/lib/udev/udevd ] ; then
  ldd /usr/lib/udev/udevd | sed "s/\t//" | cut -d " " -f1 >> $unsorted
elif [ -x /usr/lib/systemd/systemd-udevd ] ; then
  ldd /usr/lib/systemd/systemd-udevd | sed "s/\t//" | cut -d " " -f1 >> $unsorted
fi

# Add module symlinks if appropriate
if [ -n "$KERNEL_VERSION" ] && [ -x /usr/bin/kmod ] ; then
  ln -s kmod $WDIR/usr/bin/lsmod
  ln -s kmod $WDIR/usr/bin/insmod
fi

# Add lvm symlinks if appropriate
# Also copy the lvm.conf file
if  [ -x /usr/sbin/lvm ] ; then
  ln -s lvm $WDIR/usr/sbin/lvchange
  ln -s lvm $WDIR/usr/sbin/lvrename
  ln -s lvm $WDIR/usr/sbin/lvextend
  ln -s lvm $WDIR/usr/sbin/lvcreate
  ln -s lvm $WDIR/usr/sbin/lvdisplay
  ln -s lvm $WDIR/usr/sbin/lvscan

  ln -s lvm $WDIR/usr/sbin/pvchange
  ln -s lvm $WDIR/usr/sbin/pvck
  ln -s lvm $WDIR/usr/sbin/pvcreate
  ln -s lvm $WDIR/usr/sbin/pvdisplay
  ln -s lvm $WDIR/usr/sbin/pvscan

  ln -s lvm $WDIR/usr/sbin/vgchange
  ln -s lvm $WDIR/usr/sbin/vgcreate
  ln -s lvm $WDIR/usr/sbin/vgscan
  ln -s lvm $WDIR/usr/sbin/vgrename
  ln -s lvm $WDIR/usr/sbin/vgck
  # Conf file(s)
  cp -a /etc/lvm $WDIR/etc
fi

# Install libraries
sort $unsorted | uniq | while read library ; do
# linux-vdso and linux-gate are pseudo libraries and do not correspond to a file
# libsystemd-shared is in /lib/systemd, so it is not found by copy, and
# it is copied below anyway
  if [[ "$library" == linux-vdso.so.1 ]] ||
     [[ "$library" == linux-gate.so.1 ]] ||
     [[ "$library" == libsystemd-shared* ]]; then
    continue
  fi

  copy $library lib
done

if [ -d /usr/lib/udev ]; then
  cp -a /usr/lib/udev $WDIR/usr/lib
fi
if [ -d /usr/lib/systemd ]; then
  cp -a /usr/lib/systemd $WDIR/usr/lib
fi
if [ -d /usr/lib/elogind ]; then
  cp -a /usr/lib/elogind $WDIR/usr/lib
fi

# Install the kernel modules if requested
if [ -n "$KERNEL_VERSION" ]; then
  find \
     /usr/lib/modules/$KERNEL_VERSION/kernel/{crypto,fs,lib}                      \
     /usr/lib/modules/$KERNEL_VERSION/kernel/drivers/{block,ata,nvme,md,firewire} \
     /usr/lib/modules/$KERNEL_VERSION/kernel/drivers/{scsi,message,pcmcia,virtio} \
     /usr/lib/modules/$KERNEL_VERSION/kernel/drivers/usb/{host,storage}           \
     -type f 2> /dev/null | cpio --make-directories -p --quiet $WDIR

  cp /usr/lib/modules/$KERNEL_VERSION/modules.{builtin,order} \
            $WDIR/usr/lib/modules/$KERNEL_VERSION
  if [ -f /usr/lib/modules/$KERNEL_VERSION/modules.builtin.modinfo ]; then
    cp /usr/lib/modules/$KERNEL_VERSION/modules.builtin.modinfo \
            $WDIR/usr/lib/modules/$KERNEL_VERSION
  fi

  depmod -b $WDIR $KERNEL_VERSION
fi

( cd $WDIR ; find . | cpio -o -H newc --quiet | gzip -9 ) > $INITRAMFS_FILE

# Prepare early loading of microcode if available
if ls /usr/lib/firmware/intel-ucode/* >/dev/null 2>&1 ||
   ls /usr/lib/firmware/amd-ucode/*   >/dev/null 2>&1; then

# first empty WDIR to reuse it
  rm -r $WDIR/*

  DSTDIR=$WDIR/kernel/x86/microcode
  mkdir -p $DSTDIR

  if [ -d /usr/lib/firmware/amd-ucode ]; then
    cat /usr/lib/firmware/amd-ucode/microcode_amd*.bin > $DSTDIR/AuthenticAMD.bin
  fi

  if [ -d /usr/lib/firmware/intel-ucode ]; then
    cat /usr/lib/firmware/intel-ucode/* > $DSTDIR/GenuineIntel.bin
  fi

  ( cd $WDIR; find . | cpio -o -H newc --quiet ) > microcode.img
  cat microcode.img $INITRAMFS_FILE > tmpfile
  mv tmpfile $INITRAMFS_FILE
  rm microcode.img
fi

# Remove the temporary directories and files
rm -rf $WDIR $unsorted
printf "done.\n"

EOF

chmod 0755 /usr/sbin/mkinitramfs
```

```bash
mkdir -p /usr/share/mkinitramfs &&
cat > /usr/share/mkinitramfs/init.in << "EOF"
#!/bin/sh

PATH=/usr/bin:/usr/sbin
export PATH

problem()
{
   printf "Encountered a problem!\n\nDropping you to a shell.\n\n"
   sh
}

no_device()
{
   printf "The device %s, which is supposed to contain the\n" $1
   printf "root file system, does not exist.\n"
   printf "Please fix this problem and exit this shell.\n\n"
}

no_mount()
{
   printf "Could not mount device %s\n" $1
   printf "Sleeping forever. Please reboot and fix the kernel command line.\n\n"
   printf "Maybe the device is formatted with an unsupported file system?\n\n"
   printf "Or maybe filesystem type autodetection went wrong, in which case\n"
   printf "you should add the rootfstype=... parameter to the kernel command line.\n\n"
   printf "Available partitions:\n"
}

do_mount_root()
{
   mkdir /.root
   [ -n "$rootflags" ] && rootflags="$rootflags,"
   rootflags="$rootflags$ro"

   case "$root" in
      /dev/*    ) device=$root ;;
      UUID=*    ) eval $root; device="/dev/disk/by-uuid/$UUID" ;;
      PARTUUID=*) eval $root; device="/dev/disk/by-partuuid/$PARTUUID" ;;
      LABEL=*   ) eval $root; device="/dev/disk/by-label/$LABEL" ;;
      ""        ) echo "No root device specified." ; problem ;;
   esac

   while [ ! -b "$device" ] ; do
       no_device $device
       problem
   done

   if ! mount -n -t "$rootfstype" -o "$rootflags" "$device" /.root ; then
       no_mount $device
       cat /proc/partitions
       while true ; do sleep 10000 ; done
   else
       echo "Successfully mounted device $root"
   fi
}

do_try_resume()
{
   case "$resume" in
      UUID=* ) eval $resume; resume="/dev/disk/by-uuid/$UUID"  ;;
      LABEL=*) eval $resume; resume="/dev/disk/by-label/$LABEL" ;;
   esac

   if $noresume || ! [ -b "$resume" ]; then return; fi

   ls -lH "$resume" | ( read x x x x maj min x
       echo -n ${maj%,}:$min > /sys/power/resume )
}

init=/sbin/init
root=
rootdelay=
rootfstype=auto
ro="ro"
rootflags=
device=
resume=
noresume=false

mount -n -t devtmpfs devtmpfs /dev
mount -n -t proc     proc     /proc
mount -n -t sysfs    sysfs    /sys
mount -n -t tmpfs    tmpfs    /run

read -r cmdline < /proc/cmdline

for param in $cmdline ; do
  case $param in
    init=*      ) init=${param#init=}             ;;
    root=*      ) root=${param#root=}             ;;
    rootdelay=* ) rootdelay=${param#rootdelay=}   ;;
    rootfstype=*) rootfstype=${param#rootfstype=} ;;
    rootflags=* ) rootflags=${param#rootflags=}   ;;
    resume=*    ) resume=${param#resume=}         ;;
    noresume    ) noresume=true                   ;;
    ro          ) ro="ro"                         ;;
    rw          ) ro="rw"                         ;;
  esac
done

# udevd location depends on version
if [ -x /sbin/udevd ]; then
  UDEVD=/sbin/udevd
elif [ -x /lib/udev/udevd ]; then
  UDEVD=/lib/udev/udevd
elif [ -x /lib/systemd/systemd-udevd ]; then
  UDEVD=/lib/systemd/systemd-udevd
else
  echo "Cannot find udevd nor systemd-udevd"
  problem
fi

${UDEVD} --daemon --resolve-names=never
udevadm trigger
udevadm settle

if [ -f /etc/mdadm.conf ] ; then mdadm -As                       ; fi
if [ -x /sbin/vgchange  ] ; then /sbin/vgchange -a y > /dev/null ; fi
if [ -n "$rootdelay"    ] ; then sleep "$rootdelay"              ; fi

do_try_resume # This function will not return if resuming from disk
do_mount_root

killall -w ${UDEVD##*/}

exec switch_root /.root "$init" "$@"

EOF
```

使用initramfs
------------------

### 所需运行时依赖项

[cpio-2.13](12.System_utilities.md#128-cpio-213)

### 其他运行时依赖项

如果系统分区使用了initramfs，则必须先安装[LVM2-2.03.18](5.File_systems_and_disk_management.md#56-lvm2-20318) 和/或 [mdadm-4.2](5.File_systems_and_disk_management.md#59-mdadm-42) 才能生成initramfs。

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/initramfs](https://wiki.linuxfromscratch.org/blfs/wiki/initramfs)

要构建initramfs，以`root`用户运行以下命令:

```bash
mkinitramfs [KERNEL VERSION]
```

可选参数是相应内核模块所在的目录。这必须是`/lib/modules`的子目录。如果没有指定模块，则initramfs命名为initrd.img-no-kmods。如果指定了内核版本，则命名为initrd.img-$KERNEL_VERSION，只适用于指定的特定内核。输出文件将放在当前目录中。

如果需要早期加载微码(参见[the section called “Microcode updates for CPUs”](3.After_lfs_configuration_issues.md#33-about-firmware))，您可以在`/lib/firmware`中安装适当的blob或容器。它会在运行**mkinitramfs**时自动添加到initrd中。

生成initrd后，将其复制到`/boot`目录。

现在编辑`/boot/grub/grub.cfg`并添加一个新的菜单项。下面是几个例子。

```bash
# Generic initramfs and root fs identified by UUID
menuentry "LFS Dev (LFS-7.0-Feb14) initrd, Linux 3.0.4"
{
  linux  /vmlinuz-3.0.4-lfs-20120214 root=UUID=54b934a9-302d-415e-ac11-4988408eb0a8 ro
  initrd /initrd.img-no-kmods
}
```

```bash
# Generic initramfs and root fs on LVM partition
menuentry "LFS Dev (LFS-7.0-Feb18) initrd lvm, Linux 3.0.4"
{
  linux  /vmlinuz-3.0.4-lfs-20120218 root=/dev/mapper/myroot ro
  initrd /initrd.img-no-kmods
}
```

```bash
# Specific initramfs and root fs identified by LABEL
menuentry "LFS Dev (LFS-7.1-Feb20) initrd label, Linux 3.2.6"
{
  linux  /vmlinuz-3.2.6-lfs71-120220 root=LABEL=lfs71 ro
  initrd /initrd.img-3.2.6-lfs71-120220
}
```

最后，重新启动系统并选择所需的系统。


## 5.2 btrfs-progs-6.1.3
--------

简介btrfs-progs
---------------------------

btrfs-progs包包含B-tree文件系统(btrfs)的管理和调试工具。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://www.kernel.org/pub/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v6.1.3.tar.xz](https://www.kernel.org/pub/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v6.1.3.tar.xz)
    
*   下载MD5校验和: d5f703b4085dc745003c16d046d32c2b
    
*   下载大小: 2.2 MB
    
*   预计所需的磁盘空间: 53 MB (添加8.2 GB用于测试)
    
*   预计构建时间: 0.2 SBU (添加5.0 SBU用于测试，但在慢速磁盘上将花费更长时间)
    

### Btrfs-progs 依赖

#### 必要

[LZO-2.10](9.General_libraries.md#972-lzo-210)

#### 推荐

[asciidoc-10.2.0](13.Programming.md#1324-python-modules) (或 [asciidoctor-2.0.18](11.General_utilities.md#111-asciidoctor-2018)) 和 [xmlto-0.0.28](49.Extensible_markup_language_XML.md#496-xmlto-0028) (两者都需要生成手册页)

#### 可选

[LVM2-2.03.18](5.File_systems_and_disk_management.md#56-lvm2-20318) (**dmsetup**用于测试), [reiserfsprogs-3.6.27](5.File_systems_and_disk_management.md#513-reiserfsprogs-3627) (用于测试), 和 [sphinx-6.1.3](13.Programming.md#1324-python-modules) (需要构建文档),

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/btrfs-progs](https://wiki.linuxfromscratch.org/blfs/wiki/btrfs-progs)

内核配置
--------------------

在内核配置中启用以下选项并重新编译内核:

```bash
File systems --->
    <*/M> Btrfs filesystem support [CONFIG_BTRFS_FS]
```

除了上述选项以及[LVM2-2.03.18](5.File_systems_and_disk_management.md#56-lvm2-20318) 和 [reiserfsprogs-3.6.27](5.File_systems_and_disk_management.md#513-reiserfsprogs-3627)所需的选项外，运行测试还必须启用以下选项:

```bash
File systems  --->
    [*]   Btrfs POSIX Access Control Lists      [CONFIG_BTRFS_FS_POSIX_ACL]
    [*]   ReiserFS extended attributes          [CONFIG_REISERFS_FS_XATTR]
    [*]     ReiserFS POSIX Access Control Lists [CONFIG_REISERFS_FS_POSIX_ACL]
```

安装btrfs-progs
---------------------------

运行以下命令安装btrfs-progs:

```bash
./configure --prefix=/usr --disable-documentation &&
make
```

### 笔记

有些测试需要用perl正则表达式构建grep。要获得它，在安装[pcre2-10.42](9.General_libraries.md#978-pcre2-1042)之后，使用LFS第8章的指令重新构建grep。

在运行测试之前，构建支持程序:

```bash
make fssum
```

要测试结果，执行(作为`root`用户):

```bash
pushd tests
   ./fsck-tests.sh
   ./mkfs-tests.sh
   ./cli-tests.sh
   ./convert-tests.sh
   ./misc-tests.sh
   ./fuzz-tests.sh
popd
```

### 笔记

如果未启用上述内核选项，则某些测试会失败，并阻止所有剩余的测试运行，因为测试磁盘映像没有完全卸载。

mkfs测试025-zoned-parallel是已知失败的。

以`root`用户安装包:

```bash
make install
```

命令解释
--------------------

`--disable-documentation`: 如果没有安装推荐的依赖项，则需要此选项。

内容
--------

**安装程序:** btrfs, btrfs-convert, btrfs-find-root, btrfs-image, btrfs-map-logical, btrfs-select-super, btrfsck (link to btrfs), btrfstune, fsck.btrfs, 和 mkfs.btrfs

**安装库:** libbtrfs.so 和 libbtrfsutil.so

**安装目录:** /usr/include/btrfs

### 简要描述

**btrfs**               是进入btrfs文件系统操作的主要接口。

**btrfs-convert**       将ext2/3/4或reiserfs文件系统转换为btrfs。

**btrfs-find-root**     是查找btrfs根目录的过滤器。

**btrfs-map-logical**   将btrfs逻辑区段映射到物理区段。

**btrfs-select-super**  用备份副本覆盖主超级块。

**btrfstune**           调优各种文件系统参数。

**fsck.btrfs**          不执行任何操作，但为了与fstab保持一致而出现。

**mkfs.btrfs**          创建btrfs文件系统。


## 5.3 dosfstools-4.2
--------

简介dosfstools
--------------------------

dosfstools包包含用于FAT系列文件系统的各种实用程序。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://github.com/dosfstools/dosfstools/releases/download/v4.2/dosfstools-4.2.tar.gz](https://github.com/dosfstools/dosfstools/releases/download/v4.2/dosfstools-4.2.tar.gz)
    
*   下载MD5校验和: 49c8e457327dc61efab5b115a27b087a
    
*   下载大小: 314 KB
    
*   预计所需的磁盘空间: 3.5 MB
    
*   预计构建时间: 小于0.1 SBU
    

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/dosfstools](https://wiki.linuxfromscratch.org/blfs/wiki/dosfstools)

内核配置
--------------------

在内核配置中启用以下选项并重新编译内核:

```bash
File systems --->
    <DOS/FAT/EXFAT/NT Filesystems --->
        <*/M> MSDOS fs support             [CONFIG_MSDOS_FS]
        <*/M> VFAT (Windows-95) fs support [CONFIG_VFAT_FS]
```

安装dosfstools
--------------------------

运行以下命令安装dosfstools:

```bash
./configure --prefix=/usr            \
            --enable-compat-symlinks \
            --mandir=/usr/share/man  \
            --docdir=/usr/share/doc/dosfstools-4.2 &&
make
```

这个包没有附带测试套件。

现在，作为`root`用户:

```bash
make install
```

命令解释
--------------------

`--enable-compat-symlinks`: 这个开关创建了dosfsck, dosfslabel, fsck.msdos, fsck.vfat, mkdosfs, mkfs.msdos, 和 mkfs.vfat。一些程序所需的vfat符号链接。

内容
--------

**安装程序:** fatlabel, fsck.fat, 和 mkfs.fat

### 简要描述

**fatlabel**            从给定设备设置或获取MS-DOS文件系统标签。

**fsck.fat**            检查和修复MS-DOS文件系统。

**mkfs.fat**            在Linux下创建一个MS-DOS文件系统。


## 5.4 Fuse-3.13.1
--------

简介Fuse
--------------------

FUSE(用户空间中的文件系统，Filesystem in Userspace)是用户空间程序导出虚拟文件系统到Linux内核的简单接口。Fuse还旨在为非特权用户提供一种安全的方法来创建和挂载他们自己的文件系统实现。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://github.com/libfuse/libfuse/releases/download/fuse-3.13.1/fuse-3.13.1.tar.xz](https://github.com/libfuse/libfuse/releases/download/fuse-3.13.1/fuse-3.13.1.tar.xz)
    
*   下载MD5校验和: f2830b775bcba2ab9cb94f2619c077a4
    
*   下载大小: 3.9 MB
    
*   预计所需的磁盘空间: 102 MB (有测试和文档)
    
*   预计构建时间: 0.1 SBU (添加0.4 SBU用于测试)
    

### Fuse 依赖

#### 可选

[Doxygen-1.9.6](13.Programming.md#135-doxygen-196) (重建API文档) 和 [pytest-7.2.1](13.Programming.md#1324-python-modules) (测试所需)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/fuse](https://wiki.linuxfromscratch.org/blfs/wiki/fuse)

内核配置
--------------------

在内核配置中启用以下选项，必要时重新编译内核:

```bash
File systems  --->
    <*/M> FUSE (Filesystem in Userspace) support [CONFIG_FUSE_FS]
```

用户空间中的字符设备也应该启用以运行测试:

```bash
File systems  --->
    <*/M> FUSE (Filesystem in Userspace) support  [CONFIG_FUSE_FS]
    <*/M>   Character device in Userspace support [CONFIG_CUSE]
```

安装Fuse
--------------------

运行以下命令安装Fuse:

```bash
sed -i '/^udev/,$ s/^/#/' util/meson.build &&

mkdir build &&
cd    build &&

meson --prefix=/usr --buildtype=release .. &&
ninja
```

API文档包含在包中，但如果您已经安装了[Doxygen-1.9.6](13.Programming.md#135-doxygen-196)并希望重新构建它，执行:

```bash
pushd .. &&
  doxygen doc/Doxyfile &&
popd
```

要测试结果，运行(作为`root`用户):

```bash
python3 -m pytest test/
```

测试需要[pytest-7.2.1](13.Programming.md#1324-python-modules)Python模块。如果在构建内核时没有启用`CONFIG_CUSE`配置项，那么名为`test_cuse`的测试将失败。两个测试，`test_ctests.py`和`test_examples.py`'将产生警告，因为使用了已弃用的Python模块。

现在，作为`root`用户:

```bash
ninja install                  &&
chmod u+s /usr/bin/fusermount3 &&

cd ..                          &&
install -v -m755 -d /usr/share/doc/fuse-3.13.1 &&
install -v -m644    doc/{README.NFS,kernel.txt} \
                    /usr/share/doc/fuse-3.13.1 &&
cp -Rv doc/html     /usr/share/doc/fuse-3.13.1
```

命令解释
--------------------

**sed ... util/meson.build**: 该命令禁止在不需要的引导脚本和udev规则上安装。

`--buildtype=release`: 指定适合于包的稳定版本的构建类型，因为默认值可能会产生未优化的二进制文件。

配置fuse
----------------

#### 配置文件

有关挂载策略的一些选项可以在文件`/etc/fuse.conf`中设置。以`root`用户运行如下命令安装文件:

```bash
cat > /etc/fuse.conf << "EOF"
# Set the maximum number of FUSE mounts allowed to non-root users.
# The default is 1000.
#
#mount_max = 1000

# Allow non-root users to specify the 'allow_other' or 'allow_root'
# mount options.
#
#user_allow_other
EOF
```

有关配置选项含义的其他信息可在手册页中找到。

内容
--------

**安装程序:** fusermount3 和 mount.fuse3

**安装库:** libfuse3.so

**安装目录:** /usr/include/fuse3 和 /usr/share/doc/fuse-3.13.1

### 简要描述

**fusermount3**         是用于挂载和卸载Fuse文件系统的suid根程序。

**mount.fuse3**         是**mount**调用的命令，用于挂载Fuse文件系统。

`libfuse3.so`           包含FUSE API函数。


## 5.5 jfsutils-1.1.15
--------

简介jfsutils
------------------------

jfsutils包包含jfs文件系统的管理和调试工具。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://jfs.sourceforge.net/project/pub/jfsutils-1.1.15.tar.gz](https://jfs.sourceforge.net/project/pub/jfsutils-1.1.15.tar.gz)
    
*   下载MD5校验和: 8809465cd48a202895bc2a12e1923b5d
    
*   下载大小: 532 KB
    
*   预计所需的磁盘空间: 8.9 MB
    
*   预计构建时间: 0.1 SBU
    

### 额外下载

*   修复GCC 10及更新版本暴露的问题所需补丁: [https://www.linuxfromscratch.org/patches/blfs/11.3/jfsutils-1.1.15-gcc10_fix-1.patch](https://www.linuxfromscratch.org/patches/blfs/11.3/jfsutils-1.1.15-gcc10_fix-1.patch)
    

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/jfs](https://wiki.linuxfromscratch.org/blfs/wiki/jfs)

内核配置
--------------------

在内核配置中启用以下选项并重新编译内核:

```bash
File systems  --->
    <*/M> JFS filesystem support [CONFIG_JFS_FS]
```

安装jfsutils
------------------------

首先，修复GCC 10和更高版本暴露的一些问题:

```bash
patch -Np1 -i ../jfsutils-1.1.15-gcc10_fix-1.patch
```

运行以下命令安装jfsutils:

```bash
sed -i "/unistd.h/a#include <sys/types.h>"    fscklog/extract.c &&
sed -i "/ioctl.h/a#include <sys/sysmacros.h>" libfs/devices.c   &&

./configure &&
make
```

这个包没有附带测试套件。

现在，作为`root`用户:

```bash
make install
```

命令解释
--------------------

**sed ...**: 修复了使用glibc 2.28构建的问题。

内容
--------

**安装程序:** fsck.jfs, jfs_debugfs, jfs_fsck, jfs_fscklog, jfs_logdump, jfs_mkfs, jfs_tune, mkfs.jfs

**安装库:** None

**安装目录:** None

### 简要描述

**fsck.jfs**            用于重播JFS事务日志，检查JFS格式化的设备是否存在错误，并修复发现的任何错误。

**jfs_fsck**            是指向fsck.jfs的硬链接。

**mkfs.jfs**            构造一个JFS文件系统。

**jfs_mkfs**            是指向mkfs.jfs的硬链接。

**jfs_debugfs**         是一个程序，可用于在JFS格式的设备上执行各种低级操作。

**jfs_fscklog**         将JFS fsck服务日志提取到一个文件和/或格式化并显示提取的文件。

**jfs_logdump**         将日志内容从指定的JFS格式设备转储到输出文件./jfslog.dmp中。

**jfs_tune**            调整JFS文件系统上的可调文件系统参数。


## 5.6 LVM2-2.03.18
--------

简介LVM2
--------------------

LVM2包是一组管理逻辑分区的工具。它允许跨越多个物理磁盘和磁盘分区的文件系统，并提供逻辑分区的动态增长或收缩、镜像和低存储占用快照。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://sourceware.org/ftp/lvm2/LVM2.2.03.18.tgz](https://sourceware.org/ftp/lvm2/LVM2.2.03.18.tgz)
    
*   下载 (FTP): [ftp://sourceware.org/pub/lvm2/LVM2.2.03.18.tgz](ftp://sourceware.org/pub/lvm2/LVM2.2.03.18.tgz)
    
*   下载MD5校验和: cda7b89ae45ddb4a0cee768645ac9757
    
*   下载大小: 2.6 MB
    
*   预计所需的磁盘空间: 48 MB (添加25 MB用于测试;在测试期间，/tmp目录中的临时文件可以增长到大约800 MB)
    
*   预计构建时间: 0.1 SBU (使用并行数=4;根据磁盘速度增加9到48个SBU用于测试)
    

### LVM2 依赖

#### 必要

[libaio-0.3.113](9.General_libraries.md#927-libaio-03113)

#### 可选

[mdadm-4.2](5.File_systems_and_disk_management.md#59-mdadm-42), [reiserfsprogs-3.6.27](5.File_systems_and_disk_management.md#513-reiserfsprogs-3627), [Valgrind-3.20.0](13.Programming.md#1336-valgrind-3200), [Which-2.21](12.System_utilities.md#1235-which-221-and-alternatives), [xfsprogs-6.1.1](5.File_systems_and_disk_management.md#516-xfsprogs-611) (所有五种都可以用于测试，但不是必需的), [thin-provisioning-tools](https://github.com/jthornber/thin-provisioning-tools), 和 [vdo](https://github.com/dm-vdo/vdo)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/lvm2](https://wiki.linuxfromscratch.org/blfs/wiki/lvm2)

内核配置
--------------------

在内核配置中启用以下选项并重新编译内核:

### 笔记

除了下面列出的选项之外，内核中还有其他几个设备映射器选项。为了在运行回归测试时获得合理的结果，必须在内部或作为一个模块启用所有回归测试。如果没有启用Magic SysRq密钥，测试将全部超时。

```bash
Device Drivers --->
    [*] Multiple devices driver support (RAID and LVM) --->     [CONFIG_MD]
        <*/M>   Device mapper support                           [CONFIG_BLK_DEV_DM]
        <*/M>   Crypt target support                            [CONFIG_DM_CRYPT]
        <*/M>   Snapshot target                                 [CONFIG_DM_SNAPSHOT]
        <*/M>   Thin provisioning target                        [CONFIG_DM_THIN_PROVISIONING]
        <*/M>   Cache target (EXPERIMENTAL)                     [CONFIG_DM_CACHE]
        <*/M>   Mirror target                                   [CONFIG_DM_MIRROR]
        <*/M>   Zero target                                     [CONFIG_DM_ZERO]
        <*/M>   I/O delaying target                             [CONFIG_DM_DELAY]
    [*] Block devices --->
        <*/M>   RAM block device support                        [CONFIG_BLK_DEV_RAM]
Kernel hacking --->
    Generic Kernel Debugging Instruments --->
        [*] Magic SysRq key                                     [CONFIG_MAGIC_SYSRQ]
```

安装LVM2
--------------------

运行以下命令安装LVM2:

```bash
PATH+=:/usr/sbin                \
./configure --prefix=/usr       \
            --enable-cmdlib     \
            --enable-pkgconfig  \
            --enable-udev_sync  &&
make
```

测试使用udev进行逻辑卷同步，因此在运行测试之前需要安装LVM udev规则和一些实用程序。如果您是第一次安装LVM2，并且不希望在运行测试之前安装完整的软件包，则可以以` root`用户运行以下指令来安装最小实用程序集:

```bash
make -C tools install_tools_dynamic &&
make -C udev  install               &&
make -C libdm install
```

要测试结果，作为`root`用户发出命令:

```bash
LC_ALL=en_US.UTF-8 make check_local
```

有些测试可能会挂掉。在这种情况下，可以通过在**make**命令中添加**S=<testname>**来跳过它们。其他目标也可用，可以用**make -C test help**列出。测试时间很大程度上取决于磁盘的速度和启用的内核选项的数量。

测试没有实现“预期失败”的可能性，并且上游预计会出现少量测试失败。由于缺少一些内核选项，可能会发生更多的故障。例如，缺少dm-delay设备映射器目标解释了一些失败。如果/tmp目录的分区中可用的可用空间不足，则某些测试可能会失败。如果16TB不可用，则至少有一个测试失败。如果没有安装[thin-provisioning-tools](https://github.com/jthornber/thin-provisioning-tools)，一些测试会被标记为“警告”。一个解决方法是在**configure**中添加以下标志:

```bash
    --with-thin-check=    \
    --with-thin-dump=     \
    --with-thin-repair=   \
    --with-thin-restore=  \
    --with-cache-check=   \
    --with-cache-dump=    \
    --with-cache-repair=  \
    --with-cache-restore= \
```

有些测试可能会挂掉。如果需要，可以删除它们，例如:**rm test/shell/lvconvert-raid-reshape.sh**。这些测试会生成大量的内核消息，这可能会使您的终端混乱。您可以通过在运行测试之前发出**dmesg -D**来禁用它们(不要忘记在测试完成时发出**dmesg -E**)。

### 笔记

检查在/tmp目录下创建设备节点。如果/tmp使用nodev选项挂载，测试将失败。

现在，作为`root`用户:

```bash
make install
make install_systemd_units
```

命令解释
--------------------

**PATH+=:/usr/sbin**: 该路径必须包含`/usr/sbin`，以便**configure**脚本能够正常检测系统工具。该指令确保正确设置PATH，即使您作为非特权用户进行构建也是如此。

`--enable-cmdlib`: 此开关支持构建共享命令库。它在构建事件守护进程时是必需的。

`--enable-pkgconfig`: 此开关启用对“**pkg-config**”文件的支持。

`--enable-udev_sync`: 此开关启用与Udev处理同步。

`--enable-dmeventd`: 此开关支持构建Device Mapper事件守护进程。

**make install_systemd_units**: 这是安装在引导时激活逻辑卷的单元所需要的。默认情况下不安装。

配置LVM2
----------------

#### 配置文件

`/etc/lvm/lvm.conf`

#### 配置信息

默认配置仍然引用过时的`/var/lock`目录。这会在引导时造成死锁。改变这个(作为`root`用户):

```bash
sed -e '/locking_dir =/{s/#//;s/var/run/}' \
    -i /etc/lvm/lvm.conf
```

内容
--------

**安装程序:** blkdeactivate, dmeventd (可选), dmsetup, fsadm, lvm, lvmdump, 和 lvm_import_vdo. 还有许多到lvm的符号链接，它们实现了特定的功能。

**安装库:** libdevmapper.so 和 liblvm2cmd.so; 可选: libdevmapper-event.so, libdevmapper-event-lvm2.so, libdevmapper-event-lvm2mirror.so, libdevmapper-event-lvm2raid.so, libdevmapper-event-lvm2snapshot.so, libdevmapper-event-lvm2thin.so, 和 libdevmapper-event-lvm2vdo.so

**安装目录:** /etc/lvm 和 /usr/lib/device-mapper (可选)

### 简要描述

**blkdeactivate**       是一个用于停用块设备的实用程序。

**dmeventd**            (可选)是设备映射器事件守护进程。

**dmsetup**             是一个低级逻辑卷管理工具。

**fsadm**               是一个实用程序，用于调整或检查设备上的文件系统大小。

**lvm**                 为LVM2提供命令行工具。命令通过符号链接来实现，以管理物理设备(pv*)、卷组(vg*)和逻辑卷(lv*)。

**lvmdump**             是一个用于转储有关LVM2的各种信息的工具。

**vgimportclone**       用于导入复制的VG(如硬件快照)。

`libdevmapper.so`       包含设备映射器API函数。


## 5.7 About Logical Volume Management (LVM)
--------

LVM管理磁盘驱动器。它允许将多个驱动器和分区组合成更大的卷组，帮助通过快照进行备份，并允许动态调整卷大小。它还可以提供类似于RAID 1阵列的镜像。

关于LVM的完整讨论超出了本介绍的范围，但是下面将介绍一些基本概念。

要运行这里给出的任何命令，必须安装[LVM2-2.03.18](5.File_systems_and_disk_management.md#56-lvm2-20318)包。所有命令必须以`root`用户运行。

使用lvm管理磁盘是使用以下概念完成的:

物理卷

这些是物理磁盘或分区，如/dev/sda3或/dev/sdb。

卷组

这些是管理员可以操作的已命名的物理卷组。组成卷组的物理卷的数量是任意的。物理卷可以动态地从卷组中添加或移除。

逻辑卷

卷组可以再细分为多个逻辑卷。然后，每个逻辑卷都可以单独格式化，就好像它是一个普通的Linux分区一样。管理员可以根据需要动态调整逻辑卷的大小。

举一个具体的例子，假设您有两个2TB的磁盘。另外，假设一个非常大的数据库需要大量的空间，挂载在`/srv/mysql`上。下面是分区的初始集:

```bash
Partition  Use    Size      Partition Type
/dev/sda1  /boot  100MB     83 (Linux)
/dev/sda2  /       10GB     83 (Linux)
/dev/sda3  swap     2GB     82 (Swap)
/dev/sda4  LVM    remainder 8e (LVM)
/dev/sdb1  swap     2GB     82 (Swap)
/dev/sdb2  LVM    remainder 8e (LVM)
```

首先初始化物理卷:

```bash
pvcreate /dev/sda4 /dev/sdb2
```

### 笔记

一个完整的磁盘可以作为物理卷的一部分使用，但是要注意，**pvcreate**命令将破坏该磁盘上的任何分区信息。

接下来创建一个名为lfs-lvm的卷组:

```bash
vgcreate lfs-lvm /dev/sda4  /dev/sdb2
```

运行命令**vgscan**可以检查卷组的状态。现在创建逻辑卷。由于大约有3900 GB的可用空间，所以要留出大约900 GB的空间用于扩展。请注意，名为mysql的逻辑卷比任何物理磁盘都大。

```bash
lvcreate --name mysql --size 2500G lfs-lvm
lvcreate --name home  --size  500G lfs-lvm
```

最后，可以格式化和挂载逻辑卷。在本例中，jfs文件系统([jfsutils-1.1.15](jfsutils.html "jfsutils-1.1.15"))用于演示目的。

```bash
mkfs -t ext4 /dev/lfs-lvm/home
mkfs -t jfs  /dev/lfs-lvm/mysql
mount /dev/lfs-lvm/home /home
mkdir -p /srv/mysql
mount /dev/lfs-lvm/mysql /srv/mysql
```

可能需要激活这些逻辑卷，以便它们出现在`/dev`中。它们可以同时被激活，作为`root`用户:

```bash
vgchange -a y
```

LVM逻辑卷可以承载根文件系统，但需要使用initramfs(初始RAM文件系统)。在[the section called “About initramfs”](5.File_systems_and_disk_management.md#51-about-initramfs)一节中提出的initramfs允许通过内核命令行的`root=`开关传递lvm卷。

如果不使用initramfs，在systemd中会出现一个竞争条件，阻止通过`/etc/fstab`挂载逻辑卷。你必须创建一个“mount”单元(参见system.mount(5))，如下例所示，它会在引导时自动挂载`/home`目录:

```bash
cat > /etc/systemd/system/home.mount << EOF
[Unit]
Description=Mount the lvm volume /dev/lfs-lvm/home to /home

[Mount]
What=/dev/lfs-lvm/home
Where=/home
Type=ext4
Options=default

[Install]
WantedBy=multi-user.target
EOF
```

### 笔记

单元名称必须为挂载点的名称，并将 \`/' 字符替换为 \`-'，省略前面的字符。

接下来，该单元必须启用:

```bash
systemctl enable home.mount
```

有关LVM的更多信息，请参阅[LVM HOWTO](https://tldp.org/HOWTO/LVM-HOWTO/)和LVM手册页。从RedHat®可以获得一个很好的深入[guide](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/index)，尽管它有时会引用专有工具。


## 5.8 About RAID
--------

RAID (独立磁盘冗余阵列，Redundant Array of Independent Disks)是一种将多个物理磁盘组合成一个逻辑单元的存储技术。驱动器通常可以组合起来，以提供数据冗余或扩展超出物理磁盘能力的逻辑单元的大小，或者两者兼而有之。该技术还允许在不关闭系统电源的情况下提供硬件维护。

RAID组织的类型在[RAID Wiki](https://raid.wiki.kernel.org/index.php/Overview#The_RAID_levels)中有描述。

请注意，虽然RAID提供了防止磁盘故障的保护，但它不能替代备份。删除的文件在RAID组的所有硬盘上仍会被删除。现代备份通常通过[rsync-3.2.7](15.Networking_programs.md#159-rsync-327)完成。

RAID的实现方式主要有三种:硬件RAID、BIOS-based RAID和软件RAID。

硬件RAID
-------------

基于硬件的RAID通过专有的硬件和数据布局提供功能。控制和配置通常是通过固件和设备制造商提供的可执行程序一起完成的。这些功能通常通过PCI卡提供，尽管有一些RAID组件集成到主板中的实例。硬件RAID也可以在独立的机箱中使用。

基于硬件的RAID的一个优点是，驱动器作为逻辑驱动器提供给操作系统，不需要依赖于操作系统的配置。

缺点包括在将驱动器从一个系统传输到另一个系统、更新固件或更换故障的RAID硬件方面存在困难。

BIOS-based RAID
---------------

有些计算机在系统BIOS中提供了类似硬件的RAID实现。有时这被称为'假'RAID，因为这些功能通常被合并到固件中，没有任何硬件加速。

BIOS-based RAID的优点和缺点通常与硬件RAID相同，只是没有硬件加速。

在某些情况下，BIOS-based RAID固件是默认启用的(例如一些DELL系统)。如果需要使用软件RAID，则必须在BIOS中显式禁用该选项。

软件RAID
-------------

基于软件的RAID是最灵活的RAID形式。它易于安装和更新，并在系统可用的所有或部分驱动器上提供完整的功能。在BLFS中，RAID软件在[mdadm-4.2](5.File_systems_and_disk_management.md#59-mdadm-42)中找到。

使用mdm配置RAID设备非常简单。一般情况下，设备在`/dev`目录下创建为`/dev/mdx`，其中x是一个整数。

创建RAID阵列的第一步是使用分区软件，如 **`fdisk`** 或[parted-3.5](5.File_systems_and_disk_management.md#512-parted-35)来定义阵列所需的分区。通常，每个参与RAID阵列的驱动器上都有一个分区，但这并不是严格必要的。对于本例，将有四个磁盘驱动器:`/dev/sda`, `/dev/sdb`, `/dev/sdc`, 和`/dev/sdd`。它们将被划分如下:

```bash
Partition Size     Type                Use
sda1:     100 MB   fd Linux raid auto  /boot    (RAID 1) /dev/md0
sda2:      10 GB   fd Linux raid auto  /        (RAID 1) /dev/md1
sda3:       2 GB   83 Linux swap       swap
sda4      300 GB   fd Linux raid auto  /home    (RAID 5) /dev/md2

sdb1:     100 MB   fd Linux raid auto  /boot    (RAID 1) /dev/md0
sdb2:      10 GB   fd Linux raid auto  /        (RAID 1) /dev/md1
sdb3:       2 GB   83 Linux swap       swap
sdb4      300 GB   fd Linux raid auto  /home    (RAID 5) /dev/md2

sdc1:      12 GB   fd Linux raid auto  /usr/src (RAID 0) /dev/md3
sdc2:     300 GB   fd Linux raid auto  /home    (RAID 5) /dev/md2

sdd1:      12 GB   fd Linux raid auto  /usr/src (RAID 0) /dev/md3
sdd2:     300 GB   fd Linux raid auto  /home    (RAID 5) /dev/md2 
```

在这种安排中，将创建一个单独的引导分区作为第一个小RAID阵列，并创建一个根文件系统作为第二个RAID阵列，两者都是镜像的。第三个分区是用于`/home`目录的大阵列(大约1TB)。这提供了跨多个设备分条数据的能力，提高了读取和写入大文件的速度。最后，创建第四个数组，它将两个分区连接到一个更大的设备中。

### 笔记

所有mdadm命令必须以`root`用户运行。

创建RAID的命令如下:

```bash
/sbin/mdadm -Cv /dev/md0 --level=1 --raid-devices=2 /dev/sda1 /dev/sdb1
/sbin/mdadm -Cv /dev/md1 --level=1 --raid-devices=2 /dev/sda2 /dev/sdb2
/sbin/mdadm -Cv /dev/md3 --level=0 --raid-devices=2 /dev/sdc1 /dev/sdd1
/sbin/mdadm -Cv /dev/md2 --level=5 --raid-devices=4 \
        /dev/sda4 /dev/sdb4 /dev/sdc2 /dev/sdd2 
```

创建的设备可以通过设备进行检查。例如，要查看`/dev/md1`的详细信息，使用** `/sbin/mdadm --detail /dev/md1`**:

```bash
        Version : 1.2
  Creation Time : Tue Feb  7 17:08:45 2012
     Raid Level : raid1
     Array Size : 10484664 (10.00 GiB 10.74 GB)
  Used Dev Size : 10484664 (10.00 GiB 10.74 GB)
   Raid Devices : 2
  Total Devices : 2
    Persistence : Superblock is persistent

    Update Time : Tue Feb  7 23:11:53 2012
          State : clean
 Active Devices : 2
Working Devices : 2
 Failed Devices : 0
  Spare Devices : 0

           Name : core2-blfs:0  (local to host core2-blfs)
           UUID : fcb944a4:9054aeb2:d987d8fe:a89121f8
         Events : 17

    Number   Major   Minor   RaidDevice State
       0       8        1        0      active sync   /dev/sda1
       1       8       17        1      active sync   /dev/sdb1
```

从这里开始，分区可以使用选择的文件系统进行格式化(例如ext3、ext4、[xfsprogs-6.1.1](5.File_systems_and_disk_management.md#516-xfsprogs-611)、[reiserfsprogs-3.6.27](5.File_systems_and_disk_management.md#513-reiserfsprogs-3627)等)。然后可以挂载格式化的分区。`/etc/fstab`文件可以使用在引导时创建的挂载设备，`/boot/grub/grub.cfg`命令行可以指定`root=/dev/md1`。

### 笔记

交换设备应该像往常一样在`/etc/fstab`文件中指定。内核通常跨多个交换文件分割交换数据，不应该将其作为RAID阵列的一部分。

有关RAID设备的更多选项和管理细节，请参见 **`man mdadm`**。

关于监视RAID阵列和处理问题的更多细节可以在 [Linux RAID Wiki](https://raid.wiki.kernel.org/index.php/Linux_Raid) 上找到。


## 5.9 mdadm-4.2
--------

简介mdadm
---------------------

mdadm包包含软件RAID的管理工具。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://www.kernel.org/pub/linux/utils/raid/mdadm/mdadm-4.2.tar.xz](https://www.kernel.org/pub/linux/utils/raid/mdadm/mdadm-4.2.tar.xz)
    
*   下载MD5校验和: a304eb0a978ca81045620d06547050a6
    
*   下载大小: 444 KB
    
*   预计所需的磁盘空间: 5.0 MB
    
*   预计构建时间: 0.1 SBU
    

### mdadm 依赖

#### 可选

[MTA](21.Mail_server_software.md)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/mdadm](https://wiki.linuxfromscratch.org/blfs/wiki/mdadm)

### 当心

从系列4.1到4.4.1的内核版本有一个损坏的RAID实现。使用4.4.2或更高版本的内核。

内核配置
--------------------

在内核配置中启用以下选项，并在必要时重新编译内核。只需要选择所需的RAID类型。

```bash
Device Drivers --->
    [*] Multiple devices driver support (RAID and LVM) --->     [CONFIG_MD]
        <*> RAID support                                        [CONFIG_BLK_DEV_MD]
        [*]   Autodetect RAID arrays during kernel boot         [CONFIG_MD_AUTODETECT]
        <*/M>  Linear (append) mode                             [CONFIG_MD_LINEAR]
        <*/M>  RAID-0 (striping) mode                           [CONFIG_MD_RAID0]
        <*/M>  RAID-1 (mirroring) mode                          [CONFIG_MD_RAID1]
        <*/M>  RAID-10 (mirrored striping) mode                 [CONFIG_MD_RAID10]
        <*/M>  RAID-4/RAID-5/RAID-6 mode                        [CONFIG_MD_RAID456]
```

安装mdadm
---------------------

运行以下命令构建mdadm:

```bash
make
```

这个包没有附带一个工作测试套件。

现在，作为`root`用户:

```bash
make BINDIR=/usr/sbin install
```

命令解释
--------------------

**make everything**: 这个可选的目标创建额外的程序，特别是静态链接版本的**mdadm**。需要手动安装。

`--keep-going`: 即使一个或多个测试失败，也要将测试运行到底。

`--logdir=test-logs`: 定义保存测试日志的目录。

`--save-logs`: 指示测试套件保存日志。

``--tests=`<test1,test2,...>```: 可选，以逗号分隔的要执行的测试列表(如果未通过此选项，则为所有测试)。

内容
--------

**安装程序:** mdadm 和 mdmon

**安装库:** None

**安装目录:** None

### 简要描述

**mdadm**               管理MD设备又名Linux软件RAID。

**mdmon**               监控MD外部元数据阵列。


## 5.10 ntfs-3g-2022.10.3
--------

简介Ntfs-3g
-----------------------

### 笔记

一个新的NTFS读写驱动程序，称为NTFS3，从5.15版本开始被添加到Linux内核中。NTFS3的性能比ntfs-3g要好得多。要使能NTFS3，请执行以下命令:

```bash
File systems  --->
    <*/M> NTFS Read-Write file system support [CONFIG_NTFS3_FS]
```

为了确保**mount**命令使用NTFS3作为ntfs分区，需要创建一个包装脚本:

```bash
cat > /usr/sbin/mount.ntfs << "EOF" &&
#!/bin/sh
exec mount -t ntfs3 "$@"
EOF
chmod -v 755 /usr/sbin/mount.ntfs
```

有了可用的内核支持，只有在需要ntfs-3g的实用程序(例如，创建NTFS文件系统)时才需要ntfs-3g。

Ntfs-3g包包含一个稳定的、读写的开放源码驱动程序，用于NTFS分区。大多数Microsoft操作系统都使用NTFS分区。NTFS -3g允许您从Linux系统以读写模式挂载NTFS分区。它使用FUSE内核模块在用户空间中实现NTFS支持。该软件包还包含各种用于操作NTFS分区的实用程序。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://tuxera.com/opensource/ntfs-3g_ntfsprogs-2022.10.3.tgz](https://tuxera.com/opensource/ntfs-3g_ntfsprogs-2022.10.3.tgz)
    
*   下载MD5校验和: a038af61be7584b79f8922ff11244090
    
*   下载大小: 1.3 MB
    
*   预计所需的磁盘空间: 22 MB
    
*   预计构建时间: 0.2 SBU
    

### Ntfs-3g 依赖

#### 可选

[fuse 2.x](https://github.com/libfuse/libfuse) (这将禁用用户挂载)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/ntfs-3g](https://wiki.linuxfromscratch.org/blfs/wiki/ntfs-3g)

内核配置
--------------------

在内核配置中启用以下选项，必要时重新编译内核:

```bash
File systems  --->
    <*/M> FUSE (Filesystem in Userspace) support [CONFIG_FUSE_FS]
```

安装Ntfs-3g
-----------------------

运行以下命令安装Ntfs-3g:

```bash
./configure --prefix=/usr        \
            --disable-static     \
            --with-fuse=internal \
            --docdir=/usr/share/doc/ntfs-3g-2022.10.3 &&
make
```

这个包没有附带测试套件。

现在，作为`root`用户:

```bash
make install &&
```

建议使用内核内的NTFS3驱动程序来挂载NTFS文件系统，而不是ntfs-3g(请参阅本页开头的说明)。然而，如果你想用ntfs-3g来挂载NTFS文件系统，为**mount**命令创建一个符号链接:

```bash
ln -sv ../bin/ntfs-3g /usr/sbin/mount.ntfs &&
ln -sv ntfs-3g.8 /usr/share/man/man8/mount.ntfs.8
```

命令解释
--------------------

`--disable-static`: 此开关防止库的静态版本。

`--with-fuse=internal`: 这个开关动态地强制ntfs-3g使用fuse-2.x库的内部副本。如果您希望允许用户挂载NTFS分区，这是必需的。

`--disable-ntfsprogs`: 禁用用于操作NTFS分区的各种实用程序的安装。

**chmod -v 4755 /usr/bin/ntfs-3g**: 设置mount.ntfs setuid root允许非root用户挂载NTFS分区。

使用Ntfs-3g
-------------

要在引导时挂载Windows分区，在/etc/fstab中输入这样一行:

```bash
/dev/sda1 /mnt/windows auto defaults 0 0
```

为了允许用户挂载带有NTFS文件系统的u盘，在/etc/fstab中放入类似这样的一行(将sdc1更改为您系统上的u盘):

```bash
        /dev/sdc1 /mnt/usb auto user,noauto,umask=0,utf8 0 0
```

为了让用户能够挂载u盘，他们需要能够写入`/mnt/usb`，因此作为`root`用户:

```bash
chmod -v 777 /mnt/usb
```

内容
--------

**安装程序:** lowntfs-3g, mkfs.ntfs, mkntfs, mount.lowntfs-3g, mount.ntfs, mount.ntfs-3g, ntfs-3g, ntfs-3g.probe, ntfscat, ntfsclone, ntfscluster, ntfscmp, ntfscp, ntfsfix, ntfsinfo, ntfslabel, ntfsls, ntfsresize 和 ntfsundelete

**安装库:** libntfs-3g.so

**安装目录:** /usr/include/ntfs-3g 和 /usr/share/doc/ntfs-3g

### 简要描述

**lowntfs-3g**          类似于ntfs-3g，但使用Fuse底层接口。

**mkfs.ntfs**           是指向mkntfs的符号链接。

**mkntfs**              创建NTFS文件系统。

**mount.lowntfs-3g**    是到lowntfs-3g的符号链接。

**mount.ntfs**          挂载NTFS文件系统。

**mount.ntfs-3g**       是指向ntfs-3g的符号链接。

**ntfs-3g**             是一个NTFS驱动程序，它可以创建、删除、重命名、移动文件、目录、硬链接和流。它还可以读写文件，包括流、稀疏文件和透明压缩文件。它还可以处理特殊文件，如符号链接、设备和fifo;此外，它还提供文件所有权和权限的标准管理，包括POSIX ACL。

**ntfs-3g.probe**       测试NTFS卷是只读挂载还是读写挂载，并根据状态值退出。卷可以是块设备或镜像文件。

**ntfscluster**         用于标识NTFS卷中指定区域中的文件。

**ntfscp**              将文件复制到NTFS卷。

**ntfsfix**             修复常见错误并强制Windows检查NTFS分区。

**ntfsls**              列出NTFS文件系统上的目录内容。

**ntfscat**             在标准输出上打印NTFS文件和流。

**ntfsclone**           克隆NTFS文件系统。

**ntfscmp**             比较两个NTFS文件系统并显示它们的区别。

**ntfsinfo**            转储文件的属性。

**ntfslabel**           显示或更改NTFS文件系统上的标签。

**ntfsresize**          调整NTFS文件系统的大小而不丢失数据。

**ntfsundelete**        从NTFS卷中恢复已删除的文件。

`libntfs-3g.so`         包含Ntfs-3g API函数。


## 5.11 gptfdisk-1.0.9
--------

简介gptfdisk
------------------------

gptfdisk包是一组用于创建和维护GPT (GUID Partition Table)磁盘驱动器的程序。大于2TB的驱动器需要GPT分区磁盘，它是使用主引导记录(MBR)的旧PC-BIOS分区磁盘驱动器的现代替代品。主程序**gdisk**有一个类似于经典**fdisk**程序的接口。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://downloads.sourceforge.net/gptfdisk/gptfdisk-1.0.9.tar.gz](https://downloads.sourceforge.net/gptfdisk/gptfdisk-1.0.9.tar.gz)
    
*   下载MD5校验和: 01c11ecfa454096543562e3068530e01
    
*   下载大小: 212 KB
    
*   预计所需的磁盘空间: 2.3 MB
    
*   预计构建时间: 小于0.1 SBU (添加0.2 SBU用于测试)
    

### 额外下载

*   建议补丁: [https://www.linuxfromscratch.org/patches/blfs/11.3/gptfdisk-1.0.9-convenience-1.patch](https://www.linuxfromscratch.org/patches/blfs/11.3/gptfdisk-1.0.9-convenience-1.patch)
    

### gptfdisk依赖

#### 必要

[popt-1.19](9.General_libraries.md#979-popt-119)

#### 可选

[ICU-72.1](9.General_libraries.md#919-icu-721)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/gptdisk](https://wiki.linuxfromscratch.org/blfs/wiki/gptdisk)

安装gptfdisk
------------------------

gptfdisk包附带了一个基本的`Makefile`。首先，我们对其进行了更新，以提供一个简单的构建和安装界面，并修复了头文件的位置，同时还修复了最近版本的popt引入的一个问题。运行以下命令安装gptfdisk:

```bash
patch -Np1 -i ../gptfdisk-1.0.9-convenience-1.patch &&
sed -i 's|ncursesw/||' gptcurses.cc &&
sed -i 's|sbin|usr/sbin|' Makefile &&
sed -i '/UUID_H/s/^.*$/#if defined (_UUID_UUID_H) || defined (_UL_LIBUUID_UUID_H)/' guid.cc &&
sed -i "/device =/s/= \(.*\);/= strdup(\1);/" gptcl.cc &&

make
```

要测试结果，执行: **make test**.

现在，作为`root`用户:

```bash
make install
```

命令解释
--------------------

**patch -Np1 ...**: 这个补丁修改了`Makefile`文件，以便它提供一个“安装”目标。

内容
--------

**安装程序:** cgdisk, gdisk, fixparts, 和 sgdisk

### 简要描述

**cgdisk**              是用于操作GPT分区的ncurses-based工具。

**gdisk**               是用于操作GPT分区的交互式文本模式工具。

**fixparts**            修复错误格式化的基于MBR的磁盘分区。

**sgdisk**              是GPT分区操作程序，类似于**sfdisk**。


## 5.12 parted-3.5
--------

简介parted
----------------------

Parted包是一个磁盘分区和分区大小调整工具。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://ftp.gnu.org/gnu/parted/parted-3.5.tar.xz](https://ftp.gnu.org/gnu/parted/parted-3.5.tar.xz)
    
*   下载 (FTP): [ftp://ftp.gnu.org/gnu/parted/parted-3.5.tar.xz](ftp://ftp.gnu.org/gnu/parted/parted-3.5.tar.xz)
    
*   下载MD5校验和: 336fde60786d5855b3876ee49ef1e6b2
    
*   下载大小: 1.8 MB
    
*   预计所需的磁盘空间: 33 MB (额外的3 MB用于测试，额外的2 MB用于可选的PDF和Postscript文档)
    
*   预计构建时间: 0.3 SBU (额外3.6 SBU用于测试)
    

### Parted 依赖

#### 推荐

[LVM2-2.03.18](5.File_systems_and_disk_management.md#56-lvm2-20318) (device-mapper, 构建udisks时需要)

#### 可选

[dosfstools-4.2](5.File_systems_and_disk_management.md#53-dosfstools-42), [Pth-2.0.7](9.General_libraries.md#980-pth-207), [texlive-20220321](51.Typesetting.md#513-texlive-20220321-source) (或 [install-tl-unx](51.Typesetting.md#512-install-tl-unx)), 和 [Digest::CRC](https://metacpan.org/pod/Digest::CRC) (用于测试)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/parted](https://wiki.linuxfromscratch.org/blfs/wiki/parted)

测试的可选内核配置
---------------------------------------

如果构建以下内核模块，将多运行约20%的测试:

```bash
Device Drivers --->
    SCSI device support --->
        [*]  SCSI low-level drivers --->                    [CONFIG_SCSI_LOW_LEVEL]
            <M> SCSI debugging host and device simulator    [CONFIG_SCSI_DEBUG]
```

安装parted
----------------------

运行以下命令安装Parted:

```bash
./configure --prefix=/usr --disable-static &&
make &&

make -C doc html                                       &&
makeinfo --html      -o doc/html       doc/parted.texi &&
makeinfo --plaintext -o doc/parted.txt doc/parted.texi
```

如果你安装了[texlive-20220321](51.Typesetting.md#513-texlive-20220321-source)，并希望创建PDF和Postscript文档，发出以下命令:

```bash
texi2pdf             -o doc/parted.pdf doc/parted.texi &&
texi2dvi             -o doc/parted.dvi doc/parted.texi &&
dvips                -o doc/parted.ps  doc/parted.dvi
```

要测试结果，作为`root`用户发出命令:

```bash
make check
```

### 笔记

如果不以`root`用户运行，将跳过许多测试。

现在，作为`root`用户:

```bash
make install &&
install -v -m755 -d /usr/share/doc/parted-3.5/html &&
install -v -m644    doc/html/* \
                    /usr/share/doc/parted-3.5/html &&
install -v -m644    doc/{FAT,API,parted.{txt,html}} \
                    /usr/share/doc/parted-3.5
```

以`root`用户发出以下命令，安装可选的PDF和Postscript文档:

```bash
install -v -m644 doc/FAT doc/API doc/parted.{pdf,ps,dvi} \
                    /usr/share/doc/parted-3.5
```

命令解释
--------------------

`--disable-static`: 此开关防止在库的静态版本上安装。

`--disable-device-mapper`: 该选项禁用设备映射器支持。如果未安装LVM2，需要添加此参数。

内容
--------

**安装程序:** parted 和 partprobe

**安装库:** libparted.so 和 libparted-fs-resize.so

**安装目录:** /usr/include/parted 和 /usr/share/doc/parted-3.5

### 简要描述

**parted**              是一个分区操作程序。

**partprobe**           通知操作系统分区表的变化。

`libparted.so`          包含了Parted的API函数。


## 5.13 reiserfsprogs-3.6.27
--------

简介reiserfsprogs
-----------------------------

reiserfsprogs包包含用于Reiser文件系统的各种实用程序。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://www.kernel.org/pub/linux/kernel/people/jeffm/reiserfsprogs/v3.6.27/reiserfsprogs-3.6.27.tar.xz](https://www.kernel.org/pub/linux/kernel/people/jeffm/reiserfsprogs/v3.6.27/reiserfsprogs-3.6.27.tar.xz)
    
*   下载MD5校验和: 90c139542725efc6da3a6b1709695395
    
*   下载大小: 439 KB
    
*   预计所需的磁盘空间: 13 MB
    
*   预计构建时间: 0.2 SBU
    

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/reiser](https://wiki.linuxfromscratch.org/blfs/wiki/reiser)

内核配置
--------------------

在内核配置中启用以下选项并重新编译内核:

```bash
File systems --->
    <*/M> Reiserfs support [CONFIG_REISERFS_FS]
```

安装reiserfsprogs
-----------------------------

运行以下命令安装reiserfsprogs:

```bash
sed -i '/parse_time.h/i #define _GNU_SOURCE' lib/parse_time.c &&
autoreconf -fiv           &&

./configure --prefix=/usr &&
make
```

这个包没有附带测试套件。

现在，作为`root`用户:

```bash
make install
```

命令解释
--------------------

**sed ...**: 确保为最近的包含文件定义了一个变量。

内容
--------

**安装程序:** debugreiserfs, mkreiserfs, reiserfsck, reiserfstune, 和 resize_reiserfs

**安装库:** libreiserfscore.so

**安装目录:** /usr/include/reiserfs

### 简要描述

**debugreiserfs**       有时可以帮助解决ReiserFS文件系统的问题。如果在没有选项的情况下调用它，它将打印设备上找到的任何ReiserFS文件系统的超级块。

**mkreiserfs**          创建一个ReiserFS文件系统。

**reiserfsck**          用于检查或修复ReiserFS文件系统。

**reiserfstune**        用于调优ReiserFS日志。警告:在没有彻底阅读手册页之前，不要使用此实用程序。

**resize_reiserfs**     用于调整已卸载的ReiserFS文件系统的大小。


## 5.14 smartmontools-7.3
--------

简介smartmontools
-----------------------------

smartmontools包包含实用程序(smartctl, smartd)，以控制/监控存储系统使用自我监控，分析和报告技术系统(S.M.A.R.T.)内置到最现代的ATA和SCSI磁盘。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://downloads.sourceforge.net/smartmontools/smartmontools-7.3.tar.gz](https://downloads.sourceforge.net/smartmontools/smartmontools-7.3.tar.gz)
    
*   下载MD5校验和: 7a71d388124e3cd43abf6586a43cb1ff
    
*   下载大小: 1 MB
    
*   预计所需的磁盘空间: 30 MB
    
*   预计构建时间: 0.2 SBU
    

### smartmontools 依赖

#### 可选 (运行时)

[cURL-7.88.1](17.Networking_libraries.md#172-curl-7881) 或 [Lynx-2.8.9rel.1](18.Text_web_browsers.md#182-lynx-289rel1) 或 [Wget-1.21.3](15.Networking_programs.md#1511-wget-1213) (下载工具), 和 [GnuPG-2.4.0](4.Security.md#46-gnupg-240) (加密硬盘)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/smartmontools](https://wiki.linuxfromscratch.org/blfs/wiki/smartmontools)

安装smartmontools
-----------------------------

运行以下命令安装smartmontools:

```bash
./configure --prefix=/usr           \
            --sysconfdir=/etc       \
            --docdir=/usr/share/doc/smartmontools-7.3 &&
make
```

这个包没有附带测试套件。

现在，作为`root`用户:

```bash
make install
```

配置smartmontools
-------------------------

#### 配置文件

`/etc/smartd.conf`

#### 配置信息

有关定制smartd守护进程的详细说明，请参阅`/etc/smartd.conf`中嵌入的注释。

#### Systemd Unit

如果您希望在系统启动时自动启动smartd守护进程，请以`root`用户执行以下命令，启用软件包提供的systemd单元:

```bash
systemctl enable smartd
```

内容
--------

**安装程序:** smartctl, smartd, 和 update-smart-drivedb

**安装库:** None

**安装目录:** /usr/share/smartmontools, /usr/share/doc/smartmontools-7.3, 和 /etc/smartd_warning.d

### 简要描述

**smartctl**                是SMART磁盘的控制和监视实用程序。

**smartd**                  是SMART硬盘监控守护进程。

**update-smart-drivedb**    smartmontools驱动数据库的更新工具。


## 5.15 sshfs-3.7.3
--------

简介Sshfs
---------------------

Sshfs包包含一个基于SSH文件传输协议的文件系统客户端。这对于将您可以ssh访问的远程计算机挂载为本地文件系统非常有用。这允许您拖放文件或在远程文件上运行shell命令，就像在本地计算机上一样。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://github.com/libfuse/sshfs/releases/download/sshfs-3.7.3/sshfs-3.7.3.tar.xz](https://github.com/libfuse/sshfs/releases/download/sshfs-3.7.3/sshfs-3.7.3.tar.xz)
    
*   下载MD5校验和: f704f0d1800bdb5214030a1603e8c6d6
    
*   下载大小: 56 KB
    
*   预计所需的磁盘空间: 0.9 MB
    
*   预计构建时间: 小于0.1 SBU
    

### Sshfs 依赖

#### 必要

[Fuse-3.13.1](5.File_systems_and_disk_management.md#54-fuse-3131), [GLib-2.74.5](9.General_libraries.md#913-glib-2745), 和 [OpenSSH-9.2p1](4.Security.md#418-openssh-92p1).

#### 可选

[docutils-0.19](13.Programming.md#1324-python-modules) (需要构建手册页)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/sshfs](https://wiki.linuxfromscratch.org/blfs/wiki/sshfs)

安装Sshfs
---------------------

运行以下命令安装Sshfs:

```bash
mkdir build &&
cd    build &&

meson --prefix=/usr --buildtype=release .. &&
ninja
```

这个包没有附带测试套件。

现在，作为`root`用户:

```bash
ninja install
```

使用Sshfs
-----------

要挂载ssh服务器，您需要能够登录到服务器。例如，要将远程主文件夹挂载到本地的~/examplepath(该目录必须存在并且必须具有写入权限):

```bash
sshfs example.com:/home/userid ~/examplepath
```

当您完成工作并想要再次卸载它时:

```bash
fusermount3 -u ~/example
```

你也可以通过在`/etc/fstab`文件中添加类似以下的条目来挂载sshfs文件系统:

```bash
userid@example.com:/path /media/path fuse.sshfs _netdev,IdentityFile=/home/userid/.ssh/id_rsa 0 0
```

请参见 **man 1 sshfs** 和 **man 8 mount.fuse3** 了解所有可用的挂载选项。

内容
--------

**安装程序:** sshfs

**安装库:** None

**安装目录:** None

### 简要描述

**sshfs**               将**ssh**服务器挂载为本地文件系统。


## 5.16 xfsprogs-6.1.1
--------

简介xfsprogs
------------------------

xfsprogs包包含用于XFS文件系统的管理和调试工具。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://www.kernel.org/pub/linux/utils/fs/xfs/xfsprogs/xfsprogs-6.1.1.tar.xz](https://www.kernel.org/pub/linux/utils/fs/xfs/xfsprogs/xfsprogs-6.1.1.tar.xz)
    
*   下载MD5校验和: 9befb0877b9f874b0ff16bcc1f858985
    
*   下载大小: 1.3 MB
    
*   预计所需的磁盘空间: 77 MB
    
*   预计构建时间: 0.3 SBU (使用并行数=4)
    

### xfsprogs 依赖

#### 必要

[inih-56](9.General_libraries.md#920-inih-56) 和 [liburcu-0.14.0](9.General_libraries.md#963-liburcu-0140)

#### 可选

[ICU-72.1](9.General_libraries.md#919-icu-721) (用于xfs_scrub中的unicode名称扫描)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/xfs](https://wiki.linuxfromscratch.org/blfs/wiki/xfs)

内核配置
--------------------

在内核配置中启用以下选项并重新编译内核:

```bash
File systems --->
    <*/M> XFS filesystem support [CONFIG_XFS_FS]
```

安装xfsprogs
------------------------

运行以下命令安装xfsprogs:

```bash
make DEBUG=-DNDEBUG     \
     INSTALL_USER=root  \
     INSTALL_GROUP=root
```

这个包没有附带测试套件。

现在，作为`root`用户:

```bash
make PKG_DOC_DIR=/usr/share/doc/xfsprogs-6.1.1 install     &&
make PKG_DOC_DIR=/usr/share/doc/xfsprogs-6.1.1 install-dev &&

rm -rfv /usr/lib/libhandle.{a,la}
```

命令解释
--------------------

**make DEBUG=-DNDEBUG**: 关闭调试符号。

`INSTALL_USER=root INSTALL_GROUP=root`: 这将设置已安装文件的所有者和组。

`OPTIMIZER="..."`: 将此参数添加到**make**命令的末尾将覆盖默认的优化设置。

内容
--------

**安装程序:** fsck.xfs, mkfs.xfs, xfs_admin, xfs_bmap, xfs_copy, xfs_db, xfs_estimate, xfs_freeze, xfs_fsr, xfs_growfs, xfs_info, xfs_io, xfs_logprint, xfs_mdrestore, xfs_metadump, xfs_mkfile, xfs_ncheck, xfs_quota, xfs_repair, xfs_rtcp, xfs_scrub, xfs_scrub_all, 和 xfs_spaceman

**安装库:** libhandle.so

**安装目录:** /usr/include/xfs, /usr/lib/xfsprogs, /usr/share/xfsprogs, 和 /usr/share/doc/xfsprogs-6.1.1

### 简要描述

**fsck.xfs**            只是以零状态退出，因为在挂载时检查XFS分区。

**mkfs.xfs**            构造一个XFS文件系统。

**xfs_admin**           修改XFS文件系统的参数。

**xfs_bmap**            打印XFS文件的块映射。

**xfs_copy**            将XFS文件系统的内容并行地复制到一个或多个目标。

**xfs_estimate**        对于每个directory参数，估计如果将该目录复制到XFS文件系统(不跨越挂载点)将占用的空间。

**xfs_db**              用于调试XFS文件系统。

**xfs_freeze**          挂起对XFS文件系统的访问。

**xfs_fsr**             仅适用于XFS文件系统，改进了已挂载文件系统的组织，重组算法一次操作一个文件，压缩或以其他方式改进文件区(文件数据的连续块)的布局。

**xfs_growfs**          扩展XFS文件系统。

**xfs_info**            相当于调用**xfs_growfs**，但指定不对文件系统进行任何更改。

**xfs_io**              是一个类似于**xfs_db**的调试工具，但其目的是检查常规文件I/O路径，而不是原始XFS卷本身。

**xfs_logprint**        输出XFS文件系统的日志。

**xfs_mdrestore**       将XFS元转储映像还原为文件系统映像。

**xfs_metadump**        将XFS文件系统元数据复制到一个文件中。

**xfs_mkfile**          创建一个XFS文件，默认情况下用零填充。

**xfs_ncheck**          根据索引节点号为XFS文件系统生成路径名。

**xfs_quota**           是一个实用程序，用于报告和编辑文件系统配额的各个方面。

**xfs_repair**          修复损坏或损坏的XFS文件系统。

**xfs_rtcp**            将文件复制到XFS文件系统上的实时分区。

**xfs_scrub**           检查和修复挂载的XFS文件系统的内容。

**xfs_scrub_all**       擦除所有挂载的XFS文件系统。

**xfs_spaceman**        报告和控制XFS文件系统中的可用空间使用情况。

`libhandle.so`          包含XFS-specific函数，这些函数提供了一种执行某些文件系统操作的方法，而无需使用文件描述符来访问文件系统对象。


**Packages for UEFI Boot**

## 5.17 efivar-38
--------

简介efivar
----------------------

efivar包提供了操作EFI变量的工具和库。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://github.com/rhboot/efivar/releases/download/38/efivar-38.tar.bz2](https://github.com/rhboot/efivar/releases/download/38/efivar-38.tar.bz2)
    
*   下载MD5校验和: 243fdbc48440212695cb9c6e6fd0f44f
    
*   下载大小: 316 KB
    
*   预计所需的磁盘空间: 18 MB
    
*   预计构建时间: 小于0.1 SBU
    

### 额外下载

*   可选补丁(32位系统需要): [https://www.linuxfromscratch.org/patches/blfs/11.3/efivar-38-i686-1.patch](https://www.linuxfromscratch.org/patches/blfs/11.3/efivar-38-i686-1.patch)
    

### efivar 依赖

#### 必要

[mandoc-1.14.6](11.General_utilities.md#1113-mandoc-1146)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/efivar](https://wiki.linuxfromscratch.org/blfs/wiki/efivar)

安装efivar
----------------------

首先，修复Makefile中导致包在安装期间重新构建的问题:

```bash
sed '/prep :/a\\ttouch prep' -i src/Makefile
```

### 笔记

此软件包无法在具有64位UEFI实现的32位系统上正常运行。不要在32位系统上安装这个包(或efibootmgr)，除非你绝对确定你有32位的UEFI实现，这在实践中是非常罕见的。

如果在32位系统上构建此包，请应用补丁:

```bash
[ $(getconf LONG_BIT) = 64 ] || patch -Np1 -i ../efivar-38-i686-1.patch
```

使用以下命令构建efivar:

```bash
make
```

这个包的测试套件是危险的。运行它可能会触发固件错误，如果不使用一些特殊的硬件来重新编程固件，系统将无法使用。

现在，作为`root`用户:

```bash
make install LIBDIR=/usr/lib
```

命令解释
--------------------

`LIBDIR=/usr/lib`: 该选项覆盖包的默认库目录(`/usr/lib64`， LFS不使用该目录)。

内容
--------

**安装程序:** efisecdb 和 efivar

**安装库:** libefiboot.so, libefisec.so, 和 libefivar.so

**安装目录:** /usr/include/efivar

### 简要描述

**efisecdb**            是一个管理UEFI签名列表的实用程序。

**efivar**              是操纵UEFI变量的工具。

`libefiboot.so`         是**efibootmgr**使用的库。

`libefisec.so`          是一个管理UEFI签名列表的库。

`libefivar.so`          是一个用于操作EFI变量的库。


## 5.18 efibootmgr-18
--------

简介efibootmgr
--------------------------

efibootmgr包提供了操作EFI变量的工具和库。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://github.com/rhboot/efibootmgr/archive/18/efibootmgr-18.tar.gz](https://github.com/rhboot/efibootmgr/archive/18/efibootmgr-18.tar.gz)
    
*   下载MD5校验和: e170147da25e1d5f72721ffc46fe4e06
    
*   下载大小: 48 KB
    
*   预计所需的磁盘空间: 1.1 MB
    
*   预计构建时间: 小于0.1 SBU
    

### efibootmgr 依赖

#### 必要

[efivar-38](5.File_systems_and_disk_management.md#517-efivar-38) 和 [popt-1.19](9.General_libraries.md#979-popt-119)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/efibootmgr](https://wiki.linuxfromscratch.org/blfs/wiki/efibootmgr)

安装efibootmgr
--------------------------

使用以下命令构建efibootmgr:

```bash
make EFIDIR=LFS EFI_LOADER=grubx64.efi
```

这个包没有测试套件。

现在，作为`root`用户:

```bash
make install EFIDIR=LFS
```

命令解释
--------------------

`EFIDIR=LFS`: 这个选项指定发行版在`/boot/efi/EFI`下的子目录名。这个包的构建系统需要明确地设置它。

`EFI_LOADER=grubx64.efi`: 这个选项指定默认EFI引导加载程序的名称。它被设置为与GRUB提供的EFI引导加载程序匹配。

内容
--------

**安装程序:** efibootdump 和 efibootmgr

### 简要描述

**efibootdump**         是一个工具，显示单个UEFI启动选项，从文件或UEFI变量。

**efibootmgr**          是一个工具来操纵UEFI启动管理器。


## 5.19 GRUB-2.06 for EFI
--------

简介GRUB
--------------------

GRUB包提供了GRand Unified Bootloader。在本页中，它将使用UEFI支持构建，而在LFS中构建的GRUB没有启用UEFI支持。

已知此包可以使用LFS 11.3平台进行构建并正常工作。

### 包信息

*   下载 (HTTP): [https://ftp.gnu.org/gnu/grub/grub-2.06.tar.xz](https://ftp.gnu.org/gnu/grub/grub-2.06.tar.xz)
    
*   下载MD5校验和: cf0fd928b1e5479c8108ee52cb114363
    
*   下载大小: 6.3 MB
    
*   预计所需的磁盘空间: 137 MB
    
*   预计构建时间: 1.0 SBU (在64-bit LFS)
    

### 额外下载

*   需要补丁: [https://www.linuxfromscratch.org/patches/blfs/11.3/grub-2.06-upstream_fixes-1.patch](https://www.linuxfromscratch.org/patches/blfs/11.3/grub-2.06-upstream_fixes-1.patch)
    

**Unicode font data used to display GRUB menu**

*   下载 (HTTP): [https://unifoundry.com/pub/unifont/unifont-15.0.01/font-builds/unifont-15.0.01.pcf.gz](https://unifoundry.com/pub/unifont/unifont-15.0.01/font-builds/unifont-15.0.01.pcf.gz)
    
*   下载MD5校验和: c371b9b4a8a51228c468cc7efccec098
    
*   下载大小: 1.4 MB
    

**GCC (only needed if building on 32-bit LFS)**

*   下载 (HTTP): [https://ftp.gnu.org/gnu/gcc/gcc-12.2.0/gcc-12.2.0.tar.xz](https://ftp.gnu.org/gnu/gcc/gcc-12.2.0/gcc-12.2.0.tar.xz)
    
*   下载MD5校验和: 73bafd0af874439dcdb9fc063b6fb069
    
*   下载大小: 81 MB
    

### GRUB 依赖

#### 推荐

[efibootmgr-18](5.File_systems_and_disk_management.md#518-efibootmgr-18) (运行时) 和 [FreeType-2.13.0](10.Graphics_and_font_libraries.md#104-freetype-2130)

#### 可选

[LVM2-2.03.18](5.File_systems_and_disk_management.md#56-lvm2-20318)

用户笔记: [https://wiki.linuxfromscratch.org/blfs/wiki/grub-efi](https://wiki.linuxfromscratch.org/blfs/wiki/grub-efi)

安装GRUB
--------------------

首先，以`root`用户安装字体数据:

```bash
mkdir -pv /usr/share/fonts/unifont &&
gunzip -c ../unifont-15.0.01.pcf.gz > /usr/share/fonts/unifont/unifont.pcf
```

### 警告

取消设置任何可能影响构建的环境变量:

```bash
unset {C,CPP,CXX,LD}FLAGS
```

不要尝试用自定义编译标志“调优”这个包:这个包是一个引导加载程序，源代码中有低级操作，可能会被一些激进的优化破坏。

修复由e2fsprogs-1.47.0或更高版本创建`/boot`分区(或如果`/boot`不是一个单独的分区)时导致**grub-install**失败的问题:

```bash
patch -Np1 -i ../grub-2.06-upstream_fixes-1.patch
```

如果你正在运行一个32位的LFS，准备一个64位的编译器:

```bash
case $(uname -m) in i?86 )
    tar xf ../gcc-12.2.0.tar.xz
    mkdir gcc-12.2.0/build
    pushd gcc-12.2.0/build
        ../configure --prefix=$PWD/../../x86_64-gcc \
                     --target=x86_64-linux-gnu      \
                     --with-system-zlib             \
                     --enable-languages=c,c++       \
                     --with-ld=/usr/bin/ld
        make all-gcc
        make install-gcc
    popd
    export TARGET_CC=$PWD/x86_64-gcc/bin/x86_64-linux-gnu-gcc
esac
```

使用以下命令构建GRUB:

```bash
./configure --prefix=/usr        \
            --sysconfdir=/etc    \
            --disable-efiemu     \
            --enable-grub-mkfont \
            --with-platform=efi  \
            --target=x86_64      \
            --disable-werror     &&
unset TARGET_CC &&
make
```

这个包没有提供有意义的结果的测试套件。

现在，作为`root`用户:

```bash
make install &&
mv -v /etc/bash_completion.d/grub /usr/share/bash-completion/completions
```

命令解释
--------------------

`--enable-grub-mkfont`: 构建名为**grub-mkfont**的工具，根据我们安装的字体数据为引导加载程序生成字体文件。

### 警告

如果没有安装推荐的依赖项[FreeType-2.13.0](10.Graphics_and_font_libraries.md#104-freetype-2130)，则可以省略此选项并构建GRUB。但是，如果没有构建**grub-mkfont**，或者在构建GRUB时unicode字体数据不可用，GRUB将不会为引导加载程序安装任何字体。GRUB引导菜单将使用粗字体显示，内核初始化的早期阶段将处于“盲模式”—在初始化显卡驱动程序之前，您无法看到任何内核消息。诊断一些引导问题将非常困难，特别是如果图形驱动程序被构建为模块。

`--with-platform=efi`: 确保在启用EFI的情况下构建GRUB。

`--target=x86_64`: 确保为x86_64构建GRUB，即使是在32位LFS系统上构建。x86_64上的大多数EFI固件不支持32位引导加载程序。

`--target=i386`: 一些32位x86平台支持EFI。而且，一些x86_64平台有32位EFI实现，但它们非常古老和罕见。如果您**绝对确定**LFS在这样的系统上运行，请使用这个而不是`--target=x86_64`。

配置 GRUB
----------------

在UEFI平台上使用GRUB使LFS系统可启动将在[Using GRUB to Set Up the Boot Process with UEFI](grub-setup.html "Using GRUB to Set Up the Boot Process with UEFI")中讨论。

内容
--------

请参阅LFS书籍中的GRUB页面。


## 5.20 Using GRUB to Set Up the Boot Process with UEFI
--------

关闭Secure Boot
--------------------

BLFS没有支持安全引导的必要软件包。要在BLFS中设置GRUB和UEFI的启动过程，必须在固件的配置界面中关闭安全启动。请阅读系统制造商提供的文档以了解如何操作。

创建紧急Boot Disk
-----------------------------

确保紧急启动盘已准备好，以便在系统无法启动时“拯救”系统。要为基于EFI的系统制作一个带有GRUB的紧急启动磁盘，请找到一个备用USB闪存驱动器，并在其上创建一个`vfat`文件系统。首先安装[dosfstools-4.2](5.File_systems_and_disk_management.md#53-dosfstools-42)然后以`root`用户安装:

### 警告

下面的命令将擦除分区中的所有目录和文件。确保您的USB闪存驱动器不包含需要的数据，并将**`sdx1`**更改为USB闪存驱动器的第一个分区对应的设备节点。小心不要用错别字覆盖你的硬盘!

```bash
mkfs.vfat /dev/sdx1
```

仍然作为`root`用户，使用**fdisk**实用程序将USB闪存驱动器的第一个分区设置为“EFI系统”分区(将**`sdx`**更改为USB闪存驱动器对应的设备节点):

```bash
fdisk /dev/sdx

Welcome to fdisk (util-linux 2.38.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help): t
Partition number (1-9, default 9): 1
Partition type or alias (type L to list all): uefi
Changed type of partition 'Linux filesystem' to 'EFI System'.

Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

仍然作为`root`用户，为USB闪存驱动器上的EFI分区创建一个挂载点并挂载它:

```bash
mkdir -pv /mnt/rescue &&
mount -v -t vfat /dev/sdx1 /mnt/rescue
```

在分区上安装EFI GRUB:

```bash
grub-install --target=x86_64-efi --removable --efi-directory=/mnt/rescue --boot-directory=/mnt/rescue
```

卸载分区:

```bash
umount /mnt/rescue
```

现在USB闪存驱动器可以用作任何x86-64 UEFI平台上的紧急启动盘。它将引导系统并显示GRUB shell。然后，您可以键入命令从硬盘启动操作系统。要了解如何选择启动设备，请阅读主板或笔记本电脑的手册。

UEFI支持的内核配置
-------------------------------------

在内核配置中启用以下选项，必要时重新编译内核:

```bash
Processor type and features --->
    [*] EFI runtime service support                               [CONFIG_EFI]
    [*]   EFI stub support                                        [CONFIG_EFI_STUB]
Enable the block layer --->
    Partition Types --->
        [*] Advanced partition selection                            [CONFIG_PARTITION_ADVANCED]
        [*] EFI GUID Partition support                              [CONFIG_EFI_PARTITION]
Device Drivers --->
    Firmware Drivers --->
        [*] Mark VGA/VBE/EFI FB as generic system framebuffer       [CONFIG_SYSFB_SIMPLEFB]
    Graphics support --->
        <*> Direct Rendering Manager                                [CONFIG_DRM]
        [*] Enable legacy fbdev support for your modesetting driver [CONFIG_DRM_FBDEV_EMULATION]
        <*> Simple framebuffer driver                               [CONFIG_DRM_SIMPLEDRM]
        Frame buffer Devices --->
            <*> Support for frame buffer devices --->                 [CONFIG_FB]
        Console display driver support --->
            [*] Framebuffer Console support                           [CONFIG_FRAMEBUFFER_CONSOLE]
File systems --->
    <DOS/FAT/EXFAT/NT Filesystems --->
        <*/M> VFAT (Windows-95) fs support                          [CONFIG_VFAT_FS]
    Pseudo filesystems --->
        <*/M> EFI Variable filesystem                               [CONFIG_EFIVAR_FS]
```

**The meaning of the configuration options:**

`CONFIG_EFI_STUB`

在EFI系统上，GRUB通过调用EFI固件来引导Linux内核，并将其加载为EFI应用程序。因此，需要EFI存根将内核包装为EFI应用程序。

`CONFIG_SYSFB_SIMPLEFB`, `CONFIG_DRM`, `CONFIG_DRM_FBDEV_EMULATION`, `CONFIG_DRM_SIMPLEDRM`, `CONFIG_FB`, 和 `CONFIG_FRAMEBUFFER_CONSOLE`

这些选项的组合提供了UEFI framebuffer之上的Linux控制台支持。为了允许内核在早期引导阶段打印调试消息，除非使用initramfs，否则不应该将它们构建为内核模块。

查找或创建EFI系统分区
---------------------------------------

在基于EFI的系统上，引导加载程序安装在一个特殊的FAT32分区中，称为EFI系统分区(ESP)。如果您的系统支持EFI，并且预安装了某个Linux发行版或Windows的最新版本，那么很可能已经创建了ESP。作为`root`用户，列出硬盘上的所有分区(将**`sda`**替换为对应于相应硬盘的设备):

```bash
fdisk -l /dev/sda
```

ESP的“Type”一栏应为`EFI System`。

如果系统或硬盘是新的，或者是第一次安装在uefi引导的操作系统上，ESP可能不存在。在这种情况下，创建一个新的分区，在其上创建一个`vfat`文件系统，并将分区类型设置为“EFI system”。请参阅上面的紧急启动设备说明作为参考。

### 警告

一些(旧的)UEFI实现可能要求ESP是磁盘上的第一个分区。

现在，作为`root`用户，为ESP创建挂载点，并挂载它(将**`sda1`**替换为与ESP对应的设备节点):

```bash
mkdir -pv /boot/efi &&
mount -v -t vfat /dev/sda1 /boot/efi
```

在`/etc/fstab`中为ESP添加一个条目，这样它就会在系统引导时自动挂载:

```bash
cat >> /etc/fstab << EOF
/dev/sda1 /boot/efi vfat defaults 0 1
EOF
```

最小启动配置与GRUB和EFI
--------------------------------------------

在基于UEFI的系统中，GRUB通过在ESP中安装一个EFI应用程序(一种特殊的可执行文件)来工作。EFI固件将从EFI变量中记录的引导条目中搜索EFI应用程序中的引导加载程序，另外还有一个硬编码路径`EFI/BOOT/BOOTX64.EFI`。通常，应该将引导加载程序安装到自定义路径中，并且该路径应该记录在EFI变量中。如果可能的话，应该避免使用硬编码路径。然而，在某些情况下，我们必须使用硬编码路径:

*   系统还没有用EFI引导，这使得EFI变量无法访问。
    
*   EFI固件是64位的，但LFS系统是32位的，这使得EFI变量不可访问，因为内核不能用不同的虚拟地址长度调用EFI运行时服务。
    
*   LFS是为Live USB构建的，因此我们不能依赖EFI变量，它们存储在本地机器上的NVRAM或EEPROM中。
    
*   您不能或不愿意安装efibootmgr来操作EFI变量中的启动项。
    

在这些情况下，按照以下说明将GRUB EFI应用程序安装到硬编码路径中，并进行最小的引导配置。否则，最好跳过并正常设置引导配置。

要在硬编码路径`EFI/BOOT/BOOTX64.EFI`中安装EFI应用程序和GRUB，首先要确保引导分区挂载在`/boot`， ESP挂载在`/boot/efi`。然后，以`root`用户运行命令:

### 笔记

此命令将覆盖`/boot/efi/EFI/BOOT/BOOTX64.EFI`。它可能会破坏已经安装的引导加载程序。如果不确定，请备份。

```bash
grub-install --target=x86_64-efi --removable
```

该命令将GRUB EFI应用程序安装到硬编码路径`/boot/efi/EFI/BOOT/BOOTX64.EFI`中，因此EFI固件可以找到并加载它。其余的GRUB文件安装在`/boot/grub`目录中，并将在系统启动时由`BOOTX64.EFI`加载。

### 笔记

EFI固件通常更倾向于使用EFI变量中存储路径的EFI应用程序，而不是硬编码路径的EFI应用程序。因此，您可能需要调用引导选择菜单或固件设置界面，以便在下次引导时手动选择新安装的GRUB。请阅读主板或笔记本电脑的使用手册以了解如何操作。

如果您已经按照本节中的说明设置了最小的引导配置，现在请跳到“Creating the GRUB Configuration File”。

挂载EFI变量文件系统
----------------------------------

在UEFI平台上的GRUB安装需要挂载EFI变量文件系统`efivarfs`。作为`root`用户，如果它还没有挂载，挂载它:

```bash
mountpoint /sys/firmware/efi/efivars || mount -v -t efivarfs efivarfs /sys/firmware/efi/efivars
```

### 笔记

如果系统以UEFI和systemd引导，`efivarfs`将自动挂载。但是，在LFS chroot环境中，它仍然需要手动挂载。

### 警告

如果系统不是用UEFI引导，目录`/sys/firmware/efi`将会丢失。在这种情况下，您应该使用紧急启动磁盘以UEFI模式启动系统，或者使用如上所述创建的最小启动配置，然后挂载`efivarfs`并继续。

设置配置
----------------------------

在基于UEFI的系统中，GRUB通过将EFI应用程序(一种特殊的可执行文件)安装到`/boot/efi/EFI/[id]/grubx64.efi`中来工作，其中`/boot/efi`是ESP的挂载点，`[id]`被替换为在**grub-install**命令行中指定的标识符。GRUB将在EFI变量中创建一个包含路径`EFI/[id]/grubx64.efi`的条目，以便EFI固件可以找到`grubx64.efi`并加载它。

`grubx64.efi`非常轻量级(grubx64efi在GRUB-2.06中为136 KB)，因此它不会在ESP中使用太多空间。典型的ESP大小为100 MB(对于Windows引导管理器，它在ESP中使用大约50 MB)。一旦固件加载了`grubx64.efi`，它将从引导分区加载GRUB模块。默认位置是`/boot/grub`。

作为`root`用户，将GRUB文件安装到`/boot/efi/EFI/LFS/grubx64.efi`和`/boot/grub`中。然后在EFI变量中设置启动项:

```bash
grub-install --bootloader-id=LFS --recheck
```

如果安装成功，输出应该是:

```bash
Installing for x86_64-efi platform.
Installation finished. No error reported.
```

执行**efibootmgr | cut -f 1**命令重新检查EFI启动配置。输出的一个例子是:

```bash
BootCurrent: 0000
Timeout: 1 seconds
BootOrder: 0005,0000,0002,0001,0003,0004
Boot0000* ARCH
Boot0001* UEFI:CD/DVD Drive
Boot0002* Windows Boot Manager
Boot0003* UEFI:Removable Device
Boot0004* UEFI:Network Device
Boot0005* LFS
```

注意`0005`是`BootOrder`中的第一个，`Boot0005`是`LFS`。这意味着在下一次引导时，将使用LFS安装的GRUB版本来引导系统。

创建GRUB配置文件
------------------------------------

生成`/boot/grub/grub.cfg`配置GRUB的启动菜单:

```bash
BootCurrent: 0000
Timeout: 1 seconds
BootOrder: 0005,0000,0002,0001,0003,0004
Boot0000* ARCH
Boot0001* UEFI:CD/DVD Drive
Boot0002* Windows Boot Manager
Boot0003* UEFI:Removable Device
Boot0004* UEFI:Network Device
Boot0005* LFS
```

`(hd0,2)`, `sda2`, 和 `6.1.11-lfs-11.3`必须匹配您的配置。

### 笔记

从GRUB的角度来看，这些文件是相对于所使用的分区的。如果您使用了单独的/boot分区，请从上述路径(到内核和`unicode.pf2`)中删除/boot。您还需要更改“set root”行，使其指向引导分区。

`Firmware Setup`条目可用于进入固件提供的配置界面(有时称为“BIOS configuration”)。

Windows双启动
-------------------------

在`grub.cfg`中添加Windows的菜单项:

```bash
cat >> /boot/grub/grub.cfg << EOF
# Begin Windows addition

menuentry "Windows 11" {
  insmod fat
  insmod chain
  set root=(hd0,1)
  chainloader /EFI/Microsoft/Boot/bootmgfw.efi
}
EOF
```

`(hd0,1)`应该替换为GRUB为ESP指定的名称。`chainloader`指令可以用来告诉GRUB运行另一个EFI可执行文件，在这种情况下是Windows引导管理器。您可以将更多可用的EFI可执行格式的工具(例如，EFI shell)放入ESP中，并为它们创建GRUB条目。
