
# Deadline IO scheduler tunables

这个小文件试图记录截止时间 io 调度程序的工作原理。 特别是，它将阐明高级用户可能感兴趣的公开可调参数的含义。

**Selecting IO schedulers**

有关针对每个设备选择 io 调度程序的信息，请参阅切换调度程序。

**read_expire (in ms)**

Deadline io 调度程序的目标是尝试保证请求的启动服务时间。 由于我们主要关注读取延迟，因此这是可调的。 当读请求第一次进入io调度程序时，它会被分配一个截止时间，即当前时间+read_expire值（以毫秒为单位）。

**write_expire (in ms)**

与上面提到的read_expire类似，但是用于写入。

**fifo_batch (number of requests)**

请求被分组为特定数据方向（读或写）的批次，并以递增的扇区顺序提供服务。 为了限制额外的搜索，仅在批次之间检查截止日期。 fifo_batch 控制每批的最大请求数。

此参数调整每个请求延迟和聚合吞吐量之间的平衡。 当低延迟是主要考虑因素时，越小越好（其中值 1 产生先到先服务的行为）。 增加 fifo_batch 通常会提高吞吐量，但代价是延迟变化。

**writes_starved (number of dispatches)**

当我们必须将请求从 io 调度程序队列移动到块设备调度队列时，我们总是优先考虑读取。 然而，我们也不希望无限期地缺乏写入。 因此 writes_starved 控制我们优先考虑读取而不是写入的次数。 当完成 writes_starved 次数后，我们会根据与读取相同的标准调度一些写入。

**front_merges (bool)**

有时，进入 io 调度程序的请求与队列中已有的请求相邻。 它要么适合该请求的后面，要么适合前面。 这称为后合并候选者或前合并候选者。 由于文件通常的布局方式，后合并比前合并更常见。 对于某些工作负载，您甚至可能知道花费任何时间尝试前置合并请求都是浪费时间。 将 front_merges 设置为 0 将禁用此功能。 由于缓存的last_merge提示，前端合并可能仍然会发生，但由于它的成本基本上为0，所以我们将其保留。 我们只需在调用 io 调度程序合并函数时禁用 rbtree 前扇区查找即可。

Nov 11 2002, Jens Axboe <jens.axboe@oracle.com>
